// File: pprov.v
// Generated by MyHDL 0.11
// Date: Thu Mar 23 15:06:30 2023


`timescale 1ns/10ps

module pprov (
    led,
    clock,
    uart_tx
);
// a simple LED blinks example.
// This is intended to be used with the Xula, Stickit motherboard
// and an LED  pmod board.

output led;
reg led;
input clock;
output uart_tx;
wire uart_tx;

reg [24:0] cnt;
reg toggle;
reg [7:0] fifobus_write_data;
reg fifobus_write;
wire uartbaud0_reset;
reg uartbaud0_baudce;
reg uartbaud0_baudce16;
reg [10:0] uartbaud0_cnt;
reg [3:0] uartbaud0_cnt16;
reg [0:0] fifo_fast0_addr;
wire [7:0] fifo_fast0_fbus_read_data;
wire fifo_fast0_fbus_read_valid;
reg fifo_fast0_fbus_read;
reg fifo_fast0_fbus_empty;
wire fifo_fast0_fbus_clear;
reg fifo_fast0_fbus_full;
reg [0:0] fifo_fast0_nvacant;
reg [0:0] fifo_fast0_ntenant;
reg [3:0] uarttx0_bitcnt;
reg [2:0] uarttx0_state;
reg uarttx0_tx;
reg [7:0] uarttx0_txbyte;
reg [7:0] fifo_fast0_mem [0:1-1];
reg syncro0_staps [0:3-1];

assign uartbaud0_reset = 1'd0;
assign fifo_fast0_fbus_clear = 1'd0;


always @(posedge clock) begin: PPROV_BLINK
    if (($signed({1'b0, cnt}) == (32000000 - 1))) begin
        toggle <= (!toggle);
        led <= toggle;
        cnt <= 0;
    end
    else begin
        cnt <= (cnt + 1);
    end
end


always @(posedge clock) begin: PPROV_TRANSMIT
    fifobus_write_data <= A;
    fifobus_write <= 1'b1;
end


always @(posedge clock) begin: PPROV_UARTBAUD0_BEH_BAUD16
    if (uartbaud0_reset == 1) begin
        uartbaud0_cnt <= 0;
        uartbaud0_baudce16 <= 0;
    end
    else begin
        if ((uartbaud0_cnt >= 589)) begin
            uartbaud0_cnt <= (uartbaud0_cnt - 589);
            uartbaud0_baudce16 <= 1'b1;
        end
        else begin
            uartbaud0_cnt <= (uartbaud0_cnt + 36);
            uartbaud0_baudce16 <= 1'b0;
        end
    end
end


always @(posedge clock) begin: PPROV_UARTBAUD0_BEH_BAUD
    if (uartbaud0_reset == 1) begin
        uartbaud0_cnt16 <= 0;
        uartbaud0_baudce <= 0;
    end
    else begin
        if (uartbaud0_baudce16) begin
            uartbaud0_cnt16 <= (uartbaud0_cnt16 + 1);
            if ((uartbaud0_cnt16 == 0)) begin
                uartbaud0_baudce <= 1'b1;
            end
            else begin
                uartbaud0_baudce <= 1'b0;
            end
        end
        else begin
            uartbaud0_baudce <= 1'b0;
        end
    end
end


always @(posedge clock) begin: PPROV_FIFO_FAST0_BEH_SRL_IN
    integer jj;
    if (fifobus_write) begin
        fifo_fast0_mem[0] <= fifobus_write_data;
        for (jj=1; jj<1; jj=jj+1) begin
            fifo_fast0_mem[jj] <= fifo_fast0_mem[(jj - 1)];
        end
    end
end



assign fifo_fast0_fbus_read_data = fifo_fast0_mem[fifo_fast0_addr];



assign fifo_fast0_fbus_read_valid = (fifo_fast0_fbus_read && (!fifo_fast0_fbus_empty));


always @(posedge clock) begin: PPROV_FIFO_FAST0_BEH_FIFO
    if (uartbaud0_reset == 1) begin
        fifo_fast0_addr <= 0;
        fifo_fast0_fbus_empty <= 1;
        fifo_fast0_fbus_full <= 0;
    end
    else begin
        if (fifo_fast0_fbus_clear) begin
            fifo_fast0_addr <= 0;
            fifo_fast0_fbus_empty <= 1'b1;
            fifo_fast0_fbus_full <= 1'b0;
        end
        else if ((fifo_fast0_fbus_read && (!fifobus_write))) begin
            fifo_fast0_fbus_full <= 1'b0;
            if ((fifo_fast0_addr == 0)) begin
                fifo_fast0_fbus_empty <= 1'b1;
            end
            else begin
                fifo_fast0_addr <= (fifo_fast0_addr - 1);
            end
        end
        else if ((fifobus_write && (!fifo_fast0_fbus_read))) begin
            fifo_fast0_fbus_empty <= 1'b0;
            if ((!fifo_fast0_fbus_empty)) begin
                fifo_fast0_addr <= (fifo_fast0_addr + 1);
            end
            if (($signed({1'b0, fifo_fast0_addr}) == (1 - 2))) begin
                fifo_fast0_fbus_full <= 1'b1;
            end
        end
    end
end


always @(posedge clock) begin: PPROV_FIFO_FAST0_BEH_OCCUPANCY
    if (uartbaud0_reset == 1) begin
        fifo_fast0_ntenant <= 0;
        fifo_fast0_nvacant <= 1;
    end
    else begin
        if (fifo_fast0_fbus_clear) begin
            fifo_fast0_nvacant <= 1;
            fifo_fast0_ntenant <= 0;
        end
        else if ((fifo_fast0_fbus_read && (!fifobus_write))) begin
            fifo_fast0_nvacant <= (fifo_fast0_nvacant + 1);
            fifo_fast0_ntenant <= (fifo_fast0_ntenant - 1);
        end
        else if ((fifobus_write && (!fifo_fast0_fbus_read))) begin
            fifo_fast0_nvacant <= (fifo_fast0_nvacant - 1);
            fifo_fast0_ntenant <= (fifo_fast0_ntenant + 1);
        end
    end
end


always @(posedge clock) begin: PPROV_UARTTX0_BEH_TX
    if (uartbaud0_reset == 1) begin
        fifo_fast0_fbus_read <= 0;
        uarttx0_bitcnt <= 0;
        uarttx0_tx <= 1;
        uarttx0_txbyte <= 0;
        uarttx0_state <= 3'b000;
    end
    else begin
        fifo_fast0_fbus_read <= 1'b0;
        case (uarttx0_state)
            3'b000: begin
                if (((!fifo_fast0_fbus_empty) && uartbaud0_baudce)) begin
                    uarttx0_txbyte <= fifo_fast0_fbus_read_data;
                    fifo_fast0_fbus_read <= 1'b1;
                    uarttx0_state <= 3'b001;
                end
            end
            3'b001: begin
                if (uartbaud0_baudce) begin
                    uarttx0_bitcnt <= 0;
                    uarttx0_tx <= 1'b0;
                    uarttx0_state <= 3'b010;
                end
            end
            3'b010: begin
                if (uartbaud0_baudce) begin
                    uarttx0_bitcnt <= (uarttx0_bitcnt + 1);
                    uarttx0_tx <= uarttx0_txbyte[uarttx0_bitcnt];
                end
                else if ((uarttx0_bitcnt == 8)) begin
                    uarttx0_state <= 3'b011;
                    uarttx0_bitcnt <= 0;
                end
            end
            3'b011: begin
                if (uartbaud0_baudce) begin
                    uarttx0_tx <= 1'b1;
                    uarttx0_state <= 3'b100;
                end
            end
            3'b100: begin
                if (uartbaud0_baudce) begin
                    uarttx0_state <= 3'b000;
                end
            end
            default: begin
                if (1'b0 !== 1) begin
                    $display("*** AssertionError ***");
                end
            end
        endcase
    end
end


always @(posedge clock) begin: PPROV_SYNCRO0_BEH_SYNC_STAGES
    integer ii;
    syncro0_staps[0] <= uarttx0_tx;
    for (ii=1; ii<3; ii=ii+1) begin
        syncro0_staps[ii] <= syncro0_staps[(ii - 1)];
    end
end



assign uart_tx = syncro0_staps[(3 - 1)];

endmodule
